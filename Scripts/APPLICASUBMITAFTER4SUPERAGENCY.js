 var showMessage = false;									// Set to true to see results in popup windowvar showDebug = true;										// Set to true to see debug messages in popup windowvar controlString = "ApplicationSubmitAfter"; 		        // Standard choice for controlvar preExecute = "PreExecuteForAfterEvents";				// Standard choice to execute first (for globals, etc)var disableTokens = false;									// turn off tokenizing of std choices (enables use of "{} and []")var useAppSpecificGroupName = false;						// Use Group name when populating App Specific Info Valuesvar useTaskSpecificGroupName = false;						// Use Group name when populating Task Specific Info Valuesvar maxEntries = 99;										// Maximum number of std choice entries.  Entries must be Left Zero Paddedvar startDate = new Date();var startTime = startDate.getTime();var feeSeqList = new Array();						// invoicing fee listvar paymentPeriodList = new Array();					// invoicing pay periodsvar error = "";var message = "";var debug = "";var br = "<br>";var capId;var appTypeResult ;var appTypeString ;				// Convert application type to string ("Building/A/B/C")var appTypeArray ;				// Array of application type stringvar CreatedByACA;   			// Created By ACAvar servProvCode;var parentCapId = getCapId();	var childCaps = aa.cap.getChildCapByParentCapId(parentCapId); //get all child caps.if(childCaps.getSuccess()){  var caps=childCaps.getOutput();    for(var i=0;i<caps.length;i++){    //init    capId=caps[i].getCapID();    appTypeResult = caps[i].getCapType();    appTypeString = appTypeResult.toString();				// Convert application type to string ("Building/A/B/C")    appTypeArray = appTypeString.split("/");				// Array of application type string    servProvCode =capId.getServiceProviderCode();    CreatedByACA=caps[i].getCapModel().getCreatedByACA();        aa.print((i+1)+":current CapID:"+ capId);    aa.print((i+1)+":current ServiceProviderCode:"+ servProvCode);    aa.print((i+1)+":current CapType:"+ appTypeResult);    aa.print((i+1)+":current CreatedByACA:"+ CreatedByACA);            //todo it    doStandardChoiceActions(controlString,true,0);      }}else{  aa.print("Call failure.");}// Check for invoicing of feesif (feeSeqList.length){	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);	if (invoiceResult.getSuccess())		logMessage("Invoicing assessed fee items is successful.");	else		logMessage("**ERROR: Invoicing the fee items assessed to app # " + capIDString + " was not successful.  Reason: " +  invoiceResult.getErrorMessage());}if (error && error.length > 0){	aa.env.setValue("ScriptReturnCode", "1");	aa.env.setValue("ScriptReturnMessage", error);}else{	aa.env.setValue("ScriptReturnCode", "0");	aa.env.setValue("ScriptReturnMessage", message);}function getCapId()  {    var s_id1 = aa.env.getValue("PermitId1");    var s_id2 = aa.env.getValue("PermitId2");    var s_id3 = aa.env.getValue("PermitId3");    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);    if(s_capResult.getSuccess())      return s_capResult.getOutput();    else    {      logMessage("**ERROR: Failed to get capId: " + s_capResult.getErrorMessage());      return null;    }  }function logError(str){	error += str + br;}function logMessage(str){	message += str + br;}function logDebug(dstr){	debug+=dstr + br;}function appMatch(ats) // optional capId or CapID string{	var matchArray = appTypeArray //default to current app	if (arguments.length == 2) 		{		matchCapParm = arguments[1]		if (typeof(matchCapParm) == "string")			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check		else			matchCapId = matchCapParm;		if (!matchCapId)			{			logDebug("**WARNING: CapId passed to appMatch was not valid: " + arguments[1]);			return false			}		matchCap = aa.cap.getCap(matchCapId).getOutput();		matchArray = matchCap.getCapType().toString().split("/");		}			var isMatch = true;	var ata = ats.split("/");	if (ata.length != 4)		logDebug("**ERROR in appMatch.  The following Application Type String is incorrectly formatted: " + ats);	else		for (xx in ata)			if (!ata[xx].equals(matchArray[xx]) && !ata[xx].equals("*"))				isMatch = false;	return isMatch;}		function getScriptAction(strControl) {	var actArray = new Array();	var maxLength = String("" + maxEntries).length;	for (var count=1; count <= maxEntries; count++)  // Must be sequential from 01 up to maxEntries	{		var countstr = "000000" + count;		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(servProvCode,strControl,countstr);	   		   	if (bizDomScriptResult.getSuccess())	   	{			bizDomScriptObj = bizDomScriptResult.getOutput();			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());			myObj.load(bizDomScriptObj.getDescription());			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;			actArray.push(myObj);		}		else		{			break;		}	}	return actArray;}	function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent) {	var thisDate = new Date();	var thisTime = thisDate.getTime();	var lastEvalTrue = false;	logDebug("Executing: " + stdChoiceEntry + ", Elapsed Time: "  + ((thisTime - startTime) / 1000) + " Seconds")		var pairObjArray = getScriptAction(stdChoiceEntry);	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);	for (xx in pairObjArray)		{		doObj = pairObjArray[xx];		if (doExecution)			{			if (doObj.enabled)				if (eval(token(doObj.cri)) || (lastEvalTrue && doObj.continuation))					{					eval(token(doObj.act));					lastEvalTrue = true;					}				else					{					if (doObj.elseact)						eval(token(doObj.elseact));					lastEvalTrue = false;					}			}		else // just document			{			docWrite("|  ",false,docIndent);			var disableString = "";			if (!doObj.enabled) disableString = "<DISABLED>";						if (doObj.elseact)				docWrite("|  " + doObj.ID + " " + disableString + " " + doObj.cri + " ^ " + doObj.act + " ^ " + doObj.elseact ,false,docIndent);			else				docWrite("|  " + doObj.ID + " " + disableString + " " + doObj.cri + " ^ " + doObj.act,false,docIndent);			for (yy in doObj.branch)				{				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);				}			}		} // next sAction	if (!doExecution) docWrite(null,true,docIndent);	var thisDate = new Date();	var thisTime = thisDate.getTime();	logDebug("Finished: " + stdChoiceEntry + ", Elapsed Time: "  + ((thisTime - startTime) / 1000) + " Seconds")	}	function docWrite(dstr,header,indent){	var istr = "";	for (i = 0 ; i < indent ; i++)		istr+="|  ";	if (header && dstr)		aa.print(istr + "------------------------------------------------");	if (dstr) aa.print(istr + dstr);	if (header)		aa.print(istr + "------------------------------------------------");}function token(tstr){	if (!disableTokens)		{		re = new RegExp("\\{","g") ; tstr = String(tstr).replace(re,"AInfo[\"");		re = new RegExp("\\}","g") ; tstr = String(tstr).replace(re,"\"]");		}	return String(tstr); }  	function pairObj(actID){	this.ID = actID;	this.cri = null;	this.act = null;	this.elseact = null;	this.enabled = true;	this.continuation = false;	this.branch = new Array();		this.load = function(loadStr) { 		//		// load() : tokenizes and loades the criteria and action		//		loadArr = loadStr.split("\\^");		if (loadArr.length < 2 || loadArr.length > 3)			{			logMessage("**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\"^\") are required. " + br + br + loadStr)			}		else			{			this.cri     = loadArr[0];			this.act     = loadArr[1];			this.elseact = loadArr[2];			if (this.cri.length() == 0) this.continuation = true; // if format is like ("^action...") then it's a continuation of previous line						var a = loadArr[1];			var bb = a.indexOf("branch");			while (bb >= 0)			{			  var cc = a.substring(bb);			  var dd = cc.indexOf("\")");			  this.branch.push(cc.substring(8,dd));			  a = cc.substring(dd);			  bb = a.indexOf("branch");			}			  		}	}}function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap{	var feeCap = capId;	var feeCapMessage = "";	var feeSeq_L = new Array();				// invoicing fee for CAP in args	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args	if (arguments.length > 5) 	{		feeCap = arguments[5]; // use cap ID specified in args		feeCapMessage = " to specified CAP";	}		var feeItems = aa.finance.getFeeItemByCapID(feeCap).getOutput();	for(var i=0; i<feeItems.length; i++)	{		var feeItem = feeItems[i];		if(feeItem.getFeeCod() == fcode)		{			aa.finance.removeFeeItem(feeCap,feeItem.getFeeSeqNbr());		}	}	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);	if (assessFeeResult.getSuccess())	{		feeSeq = assessFeeResult.getOutput();		logMessage("Successfully added Fee " + fcode + ", Qty " + fqty + feeCapMessage);		logDebug("The assessed fee Sequence Number " + feeSeq + feeCapMessage);		if (finvoice == "Y" && arguments.length == 5) // use current CAP			{			feeSeqList.push(feeSeq);			paymentPeriodList.push(fperiod);			}		if (finvoice == "Y" && arguments.length > 5) // use CAP in args			{			feeSeq_L.push(feeSeq);			paymentPeriod_L.push(fperiod);			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);			if (invoiceResult_L.getSuccess())				logMessage("Invoicing assessed fee items" + feeCapMessage + " is successful.");			else				logDebug("**ERROR: Invoicing the fee items assessed" + feeCapMessage + " was not successful.  Reason: " +  invoiceResult.getErrorMessage());			}	}	else	{		logDebug( "**ERROR: assessing fee (" + fcode + "): " + assessFeeResult.getErrorMessage());	}}	